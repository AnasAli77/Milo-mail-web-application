@startuml
title Milo Mail System - Sequence Diagrams

== Email Filtering & Sorting Workflow (Strategy + Criteria Pattern) ==

actor User
participant "Angular Frontend\n(Observer Pattern)" as Frontend
participant "MailController\n(Facade)" as Controller
participant "MailService\n(Facade)" as Service
participant "CriteriaFactory" as CFactory
participant "Criteria" as Filter
participant "SortWorker" as Worker
participant "MailSortingStrategy" as Strategy
database "PostgreSQL" as DB

User -> Frontend : Apply Filter & Sort
activate Frontend

Frontend -> Controller : GET /mails/filter
activate Controller

Controller -> Service : Filter(filterDTO, page, size)
activate Service

Service -> DB : findByFolderAndUser()
activate DB
DB --> Service : List<Mail> rawMails
deactivate DB

note over Service: Apply Criteria Pattern

Service -> CFactory : create("subject", "work")
activate CFactory
CFactory --> Service : CriteriaSubject
deactivate CFactory

Service -> Filter : filter(rawMails)
activate Filter
Filter --> Service : filteredMails
deactivate Filter

note over Service: Apply Strategy Pattern

Service -> Worker : setStrategy(SortByDate)
activate Worker
Worker --> Service
deactivate Worker

Service -> Worker : sort(filteredMails)
activate Worker
Worker -> Strategy : SortingMails(filteredMails)
activate Strategy
Strategy --> Worker : sortedMails
deactivate Strategy
Worker --> Service : sortedMails
deactivate Worker

Service --> Controller : Page<MailDTO>
deactivate Service

Controller --> Frontend : JSON Response
deactivate Controller

Frontend -> User : Display Filtered & Sorted Mails
deactivate Frontend

== Filter Rule Application (Command Pattern) ==

actor Sender
participant "Angular Frontend\n(Observer Pattern)" as Frontend2
participant "MailController" as Controller2
participant "MailService\n(Facade)" as Service2
participant "FilterRuleRepo" as RuleRepo
participant "FilterRule" as Rule
participant "ActionFactory" as AFactory
participant "FilterRuleAction" as Action
participant "FolderRepo" as FolderRepo
database "PostgreSQL" as DB2

Sender -> Frontend2 : Click "Send"
activate Frontend2

note over Frontend2: Validates:\n- Subject not empty\n- Body not empty\n- Receivers valid

Frontend2 -> Controller2 : POST /mail/add
activate Controller2

Controller2 -> Service2 : saveMail(mailDTO, files)
activate Service2

note over Service2: Save sender's copy first

Service2 -> DB2 : save(senderMail)
activate DB2
DB2 --> Service2 : savedMail
deactivate DB2

note over Service2: Process each receiver\n(Prototype Pattern creates copies)

loop For each receiver email
    Service2 -> Service2 : new Mail(senderMail, receiver)
    note right: Prototype Pattern\n(Deep copy with receiver)
    
    Service2 -> RuleRepo : findByUserEmail(receiverEmail)
    activate RuleRepo
    RuleRepo --> Service2 : List<FilterRule>
    deactivate RuleRepo

    loop For each FilterRule
        Service2 -> Rule : check(mail)
        activate Rule
        note right: Criteria Pattern\niterates criteriaTypesValues
        Rule --> Service2 : boolean matches
        deactivate Rule
        
        alt If rule matches
            Service2 -> Rule : apply(mail, actionFactory)
            activate Rule
            
            Rule -> AFactory : getAction(actionType)
            activate AFactory
            note right: Factory Pattern
            AFactory --> Rule : FilterRuleAction
            deactivate AFactory
            
            Rule -> Action : execute(mail, targetValue)
            activate Action
            note right: Command Pattern\nActions:\n- MoveToAction\n- StarAction\n- MarkAsReadAction
            Action -> FolderRepo : findByNameAndUserEmail()
            Action --> Rule
            deactivate Action
            
            Rule --> Service2
            deactivate Rule
        end
    end
    
    alt If no folder set
        Service2 -> FolderRepo : findByNameAndUserEmail("inbox", email)
        Service2 -> Service2 : mail.setFolder(inbox)
    end
    
    Service2 -> DB2 : save(receiverMail)
end

Service2 --> Controller2 : success
deactivate Service2

Controller2 --> Frontend2 : 200 OK
deactivate Controller2

Frontend2 --> Sender : "Email Sent Successfully"
deactivate Frontend2

== Authentication Flow (Chain of Responsibility) ==

actor User2 as User3
participant "Angular Frontend" as Frontend3
participant "JWTFilter\n(Chain of Responsibility)" as JWTFilter
participant "SecurityFilterChain" as Chain
participant "AuthController" as AuthCtrl
participant "AuthService" as AuthSvc
participant "JWTService" as JWTSvc
database "PostgreSQL" as DB3

User3 -> Frontend3 : Login Request
activate Frontend3

Frontend3 -> AuthCtrl : POST /auth/login
activate AuthCtrl

AuthCtrl -> AuthSvc : verify(userDTO)
activate AuthSvc

AuthSvc -> DB3 : findByEmail(email)
activate DB3
DB3 --> AuthSvc : ClientUser
deactivate DB3

AuthSvc -> JWTSvc : generateToken(email)
activate JWTSvc
JWTSvc --> AuthSvc : JWT Token
deactivate JWTSvc

AuthSvc --> AuthCtrl : UserDTO with token
deactivate AuthSvc

AuthCtrl --> Frontend3 : { token, email, name }
deactivate AuthCtrl

Frontend3 -> Frontend3 : Store token in sessionStorage

note over Frontend3: Subsequent requests use\nAuthInterceptor (Interceptor Pattern)

Frontend3 -> JWTFilter : GET /mail/all (with Bearer token)
activate JWTFilter

JWTFilter -> JWTFilter : Extract token from header
JWTFilter -> JWTSvc : extractEmail(token)
JWTFilter -> JWTSvc : validateToken(token, userDetails)

alt Token Valid
    JWTFilter -> Chain : filterChain.doFilter()
    note right: Chain of Responsibility\npasses to next filter
else Token Invalid
    JWTFilter --> Frontend3 : 401 Unauthorized
end

deactivate JWTFilter
deactivate Frontend3

@enduml
