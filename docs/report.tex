\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}
\usepackage{float}
\usepackage{enumitem}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Milo Mail System Project Report}
\author{
    Team Milo \\
    \vspace{0.3cm}
    Mostafa Fathy Ali Amer (23010849) \\
    Youssef Ashraf Mohamed Soliman (23010977) \\
    Anas Ali Mohamed Ahmed (23010300) \\
    Bigad Elsayed Ramadan Omar (23010327)
}
\date{}

\begin{document}

\maketitle

\section{Introduction}
This report covers the design and implementation of the Milo Mail System, which is a web-based email application we built for our Programming 2 course. We used \textbf{Spring Boot with JDK 21} for the backend and \textbf{Angular 20} for the frontend, along with a \textbf{PostgreSQL} database to store everything. We tried to follow Object-Oriented Programming principles and used several GoF design patterns to keep the code clean and easy to extend.

\section{Steps to Run the Code}
\subsection{Prerequisites}
\begin{itemize}
    \item Java Development Kit (JDK) 21
    \item Maven
    \item Node.js (v18+) and npm
    \item Angular CLI
    \item PostgreSQL Database (running on default port 5432)
\end{itemize}

\subsection{Database Setup}
\begin{enumerate}
    \item Ensure PostgreSQL is running on port \texttt{5432}.
    \item Create a database named \texttt{dilo}.
    \item Update credentials in \texttt{Milo-Backend/src/main/resources/application.properties} if they differ from:
    \begin{verbatim}
    spring.datasource.username=postgres
    spring.datasource.password=12345678
    \end{verbatim}
\end{enumerate}

\subsection{Backend Setup}
\begin{enumerate}
    \item Navigate to the \texttt{Milo-Backend} directory.
    \item Run the following command to start the server:
    \begin{verbatim}
    mvn spring-boot:run
    \end{verbatim}
    \item The backend API will start at \texttt{http://localhost:8080}.
\end{enumerate}

\subsection{Frontend Setup}
\begin{enumerate}
    \item Navigate to the \texttt{Milo} directory.
    \item Install dependencies:
    \begin{verbatim}
    npm install
    \end{verbatim}
    \item Start the development server:
    \begin{verbatim}
    ng serve
    \end{verbatim}
    \item Access the application in your browser at \texttt{http://localhost:4200}.
\end{enumerate}

\section{UML Diagrams}
\subsection{Class Diagram}
The Class Diagram illustrates the structural relationship between the core entities (\texttt{Mail}, \texttt{Attachment}, \texttt{User}) and the behavioral patterns (\texttt{Strategy} hierarchy for sorting, \texttt{Criteria} hierarchy for filtering).

\textit{(Please insert the generated class\_diagram.puml visualization here)}

\subsection{Sequence Diagram}
The Sequence Diagram depicts the workflow of a user filtering and sorting emails. It shows the interaction flow from the Frontend to the Controller, Service, Filter Factory, and Sorting Worker.

\textit{(Please insert the generated sequence\_diagram.puml visualization here)}

\section{Design Patterns Applied}

\subsection{Backend Design Patterns}

\subsubsection{Strategy Pattern (Behavioral)}
\textbf{Usage:} Used for sorting emails and contacts dynamically.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Mail Sorting:} \texttt{MailSortingStrategy} interface with concrete implementations: \texttt{SortByDate}, \texttt{SortBySubject}, \texttt{SortByPriority}, \texttt{SortBySender}, \texttt{SortByReceiver}, \texttt{SortByBody}, \texttt{SortByAttachment}.
    \item \textbf{Contact Sorting:} \texttt{ContactSortingStrategy} interface with: \texttt{ContactSortByName}, \texttt{ContactSortByEmails}.
    \item \textbf{Context:} \texttt{SortWorker} and \texttt{ContactSortWorker} classes.
\end{itemize}
This allows the sorting algorithm to be switched at runtime without modifying the client code in the Service.

\subsubsection{Criteria / Filter Pattern (Structural)}
\textbf{Usage:} Used to filter emails based on multiple conditions.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Interface:} \texttt{Criteria} (defines \texttt{filter(List<Mail>)} method).
    \item \textbf{Concrete Criteria:} \texttt{CriteriaSender}, \texttt{CriteriaReceiver}, \texttt{CriteriaSubject}, \texttt{CriteriaBody}, \texttt{CriteriaPriority}, \texttt{CriteriaDay}, \texttt{CriteriaMonth}, \texttt{CriteriaYear}, \texttt{CriteriaHour}, \texttt{CriteriaMinute}, \texttt{CriteriaHasAttachment}.
\end{itemize}
This pattern decouples the filtering logic from the Mail entity and the Service.

\subsubsection{Factory Pattern (Creational)}
\textbf{Usage:} Used to instantiate the correct Filter/Criteria and Action objects based on user input.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \texttt{CriteriaFactory}: Takes a string (e.g., ``subject'') and returns a \texttt{CriteriaSubject} instance.
    \item \texttt{ActionFactory}: Takes an action type string (e.g., ``move'', ``star'', ``markasread'') and returns the corresponding \texttt{FilterRuleAction} implementation.
\end{itemize}
This encapsulates object creation logic, simplifying the Service layer.

\subsubsection{Builder Pattern (Creational)}
\textbf{Usage:} Used for constructing complex \texttt{Mail} objects.
\newline
\textbf{Implementation:} Annotated with \texttt{@Builder} (Lombok) in the \texttt{Mail} class. This provides a fluent API for object construction (\texttt{Mail.builder().subject(...).build()}), making the code more readable and reducing constructor complexity.

\subsubsection{Prototype Pattern (Creational)}
\textbf{Usage:} We use this pattern to deep-copy mails when sending them to multiple receivers or when sending a draft.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Interface:} \texttt{Prototype\textless T\textgreater} defines the \texttt{clone()} method.
    \item \textbf{Concrete Prototype:} \texttt{Mail} implements \texttt{Prototype\textless Mail\textgreater} with \texttt{clone()} and \texttt{cloneWithReceiver(ClientUser)} methods.
    \item The \texttt{clone()} method creates a deep copy of the mail including all attachments, ensuring each receiver gets their own independent copy.
\end{itemize}

\subsubsection{Command Pattern (Behavioral)}
\textbf{Usage:} Used for executing filter rule actions on incoming emails.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Command Interface:} \texttt{FilterRuleAction} defines the \texttt{execute(Mail, String)} method.
    \item \textbf{Concrete Commands:} \texttt{MoveToAction}, \texttt{StarAction}, \texttt{MarkAsReadAction}.
    \item \textbf{Invoker:} \texttt{FilterRule} checks criteria and invokes actions.
    \item \textbf{Factory:} \texttt{ActionFactory} creates the appropriate action based on action type.
\end{itemize}

\subsubsection{Facade Pattern (Structural)}
\textbf{Usage:} Used to provide a simplified interface to complex subsystems.
\newline
\textbf{Implementation:} \texttt{MailService} acts as a facade, coordinating multiple repositories (\texttt{MailRepo}, \texttt{UserRepo}, \texttt{FolderRepo}), mappers, and the \texttt{ActionFactory} to provide high-level operations like \texttt{saveMail()}, \texttt{Search()}, and \texttt{Filter()}.

\subsubsection{Singleton Pattern (Creational)}
\textbf{Usage:} Ensures a class has only one instance.
\newline
\textbf{Implementation:} All Spring \texttt{@Service}, \texttt{@Repository}, and \texttt{@Component} annotated classes are managed as singletons by the Spring IoC container by default.

\subsubsection{Chain of Responsibility Pattern (Behavioral)}
\textbf{Usage:} Used for processing HTTP requests through security filters.
\newline
\textbf{Implementation:} \texttt{JWTFilter} extends \texttt{OncePerRequestFilter} and participates in Spring Security's filter chain, processing JWT tokens and passing requests to the next handler via \texttt{filterChain.doFilter()}.

\subsubsection{Mapper Pattern (Structural)}
\textbf{Usage:} Used to convert between DTOs and Entity objects.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \texttt{MailMapper} / \texttt{MailMapperImpl}: Converts \texttt{MailDTO} to \texttt{Mail} entity.
    \item \texttt{AttachmentMapper} / \texttt{AttachmentMapperImpl}: Converts attachment DTOs to \texttt{Attachment} entities.
\end{itemize}

\subsection{Frontend Design Patterns}

\subsubsection{Observer Pattern (Reactive Programming)}
\textbf{Usage:} Used for reactive state management and component communication.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Angular Signals:} Used for reactive local state (e.g., \texttt{currentFolder}, \texttt{selectedEmail}, \texttt{filters}).
    \item \textbf{RxJS Observables:} Used for HTTP communication and async data streams.
    \item \textbf{Computed Signals:} Derived state that automatically updates when dependencies change.
\end{itemize}

\subsubsection{Interceptor Pattern}
\textbf{Usage:} Used to intercept and modify HTTP requests globally.
\newline
\textbf{Implementation:} \texttt{AuthInterceptor} adds JWT Bearer tokens to all outgoing HTTP requests automatically.

\section{Design Decisions}
\begin{enumerate}
    \item \textbf{Framework Choice:} We went with Spring Boot because it makes building REST APIs really easy and has great dependency injection. It also means we could scale this to microservices later if needed.
    \item \textbf{Database:} We picked PostgreSQL since it's reliable and has advanced SQL features. It runs on port 5432.
    \item \textbf{Caching with Caffeine:} We noticed that loading mails was getting slow, especially when users had lots of emails. To fix this, we added a caching layer using Caffeine. We chose Caffeine because it's a local cache that can store Java objects directly without needing to serialize them, which is really convenient.
    \item \textbf{Handling Concurrency:} To avoid issues where a user edits a draft while it's being autosaved, we made the backend always treat sent mails as brand new entities using the Prototype pattern. This prevents those annoying Optimistic Locking exceptions.
    \item \textbf{Asynchronous UI:} The frontend uses Angular Signals and Observables for handling large file uploads asynchronously. We also added a global loading overlay so users can see when something is still loading.
    \item \textbf{Filter Rule Architecture:} Filter rules get applied on the receiver's side when mail is delivered, not the sender's side. This way each user's filters work independently on their own incoming mail.
    \item \textbf{Defensive Null Handling:} All our Criteria classes check for null values to prevent NullPointerExceptions during filtering. We also wrapped the filter logic in try-catch so even if a filter crashes, the email still gets delivered.
    \item \textbf{Synchronized Star Status for Self-Sent Emails:} When you send an email to yourself, you end up with two copies (one in Sent, one in Inbox). We made it so starring either copy automatically stars both. Also, the Starred folder only shows one copy to avoid duplicates.
\end{enumerate}

\section{Assumptions}
\begin{enumerate}
    \item \textbf{Email Composition:} When composing an email, the subject, body, and at least one valid receiver email are required. Empty fields are not permitted to ensure meaningful communication.
    \item \textbf{Email Validation:} Receiver email addresses must match the pattern \texttt{user@domain.com}. Invalid formats are rejected on the frontend before submission.
    \item \textbf{Priority Levels:} Emails support 5 priority levels: 1 (Very Low), 2 (Low), 3 (Normal - default), 4 (High), 5 (Extreme).
    \item \textbf{Folder Structure:} System folders (Inbox, Sent, Drafts, Trash, Starred) are created automatically for each user. Users can create custom folders.
    \item \textbf{Filter Actions:} Only one action can be applied per filter rule. Priority order: Move To Folder > Star > Mark as Read.
    \item \textbf{Authentication:} JWT tokens are stored in \texttt{sessionStorage} and automatically attached to all API requests via the interceptor.
    \item \textbf{Attachment Handling:} Attachments are deep-copied when sending drafts to ensure sender and receiver have independent copies in the database.
    \item \textbf{Trash Cleanup:} A scheduled service (\texttt{TrashCleanupService}) periodically cleans old emails from trash folders.
\end{enumerate}

\section{User Guide}
\subsection{Registration \& Login}
Users can sign up with a unique email. The system checks against the database and alerts if the email is taken.
\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Login/Signup Screenshot] \vspace{2cm}}}
    \caption{Login Page}
\end{figure}

\subsection{Inbox \& Filtering}
Users can view their inbox and apply filters (e.g., by Sender or Subject) and sort the results.
\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Inbox Screenshot] \vspace{2cm}}}
    \caption{Inbox with Filtering functionality}
\end{figure}

\subsection{Composing Emails}
The Compose window allows sending emails with priority and attachments. Subject, body, and receivers are mandatory fields.
\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Compose Window Screenshot] \vspace{2cm}}}
    \caption{Compose Email Modal}
\end{figure}

\subsection{Filter Rules}
Users can create custom filter rules to automatically organize incoming emails. Filter rules allow users to define criteria (sender, subject, body, priority, date, attachments) and actions (move to folder, star, mark as read) that are applied when emails matching the criteria are received.
\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Filter Rules Screenshot] \vspace{2cm}}}
    \caption{Filter Rules Management}
\end{figure}

\textbf{Available Criteria:}
\begin{itemize}
    \item From (sender email/name)
    \item To (recipient email)
    \item Subject contains
    \item Body contains keywords
    \item Priority level (1-5)
    \item Date (Year, Month, Day)
    \item Has attachments
\end{itemize}

\textbf{Available Actions:}
\begin{itemize}
    \item Move to folder (Inbox, Trash, or custom folders)
    \item Star the email
    \item Mark as read
\end{itemize}

\end{document}
