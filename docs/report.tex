\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}
\usepackage{float}
\usepackage{enumitem}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Milo Mail System Project Report}
\author{Team Milo}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
This report documents the design and implementation of the Milo Mail System, a scalable web-based email application. The system is built using \textbf{Spring Boot (Java 21/25)} for the backend and \textbf{Angular 19} for the frontend, using a \textbf{PostgreSQL} database for persistence. The application conforms to Object-Oriented Programming principles and utilizes several GoF design patterns to ensure maintainability and extensibility.

\section{Steps to Run the Code}
\subsection{Prerequisites}
\begin{itemize}
    \item Java Development Kit (JDK) 21 or 25
    \item Maven
    \item Node.js (v18+) and npm
    \item Angular CLI
    \item PostgreSQL Database (running on default port 5432)
\end{itemize}

\subsection{Database Setup}
\begin{enumerate}
    \item Ensure PostgreSQL is running on port \texttt{5432}.
    \item Create a database named \texttt{dilo}.
    \item Update credentials in \texttt{Milo-Backend/src/main/resources/application.properties} if they differ from:
    \begin{verbatim}
    spring.datasource.username=postgres
    spring.datasource.password=12345678
    \end{verbatim}
\end{enumerate}

\subsection{Backend Setup}
\begin{enumerate}
    \item Navigate to the \texttt{Milo-Backend} directory.
    \item Run the following command to start the server:
    \begin{verbatim}
    mvn spring-boot:run
    \end{verbatim}
    \item The backend API will start at \texttt{http://localhost:8080}.
\end{enumerate}

\subsection{Frontend Setup}
\begin{enumerate}
    \item Navigate to the \texttt{Milo} directory.
    \item Install dependencies:
    \begin{verbatim}
    npm install
    \end{verbatim}
    \item Start the development server:
    \begin{verbatim}
    ng serve
    \end{verbatim}
    \item Access the application in your browser at \texttt{http://localhost:4200}.
\end{enumerate}

\section{UML Diagrams}
\subsection{Class Diagram}
The Class Diagram illustrates the structural relationship between the core entities (\texttt{Mail}, \texttt{Attachment}, \texttt{User}) and the behavioral patterns (\texttt{Strategy} hierarchy for sorting, \texttt{Criteria} hierarchy for filtering).

\textit{(Please insert the generated class\_diagram.puml visualization here)}

\subsection{Sequence Diagram}
The Sequence Diagram depicts the workflow of a user filtering and sorting emails. It shows the interaction flow from the Frontend to the Controller, Service, Filter Factory, and Sorting Worker.

\textit{(Please insert the generated sequence\_diagram.puml visualization here)}

\section{Design Patterns Applied}

\subsection{Backend Design Patterns}

\subsubsection{Strategy Pattern (Behavioral)}
\textbf{Usage:} Used for sorting emails and contacts dynamically.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Mail Sorting:} \texttt{MailSortingStrategy} interface with concrete implementations: \texttt{SortByDate}, \texttt{SortBySubject}, \texttt{SortByPriority}, \texttt{SortBySender}, \texttt{SortByReceiver}, \texttt{SortByBody}, \texttt{SortByAttachment}.
    \item \textbf{Contact Sorting:} \texttt{ContactSortingStrategy} interface with: \texttt{ContactSortByName}, \texttt{ContactSortByEmails}.
    \item \textbf{Context:} \texttt{SortWorker} and \texttt{ContactSortWorker} classes.
\end{itemize}
This allows the sorting algorithm to be switched at runtime without modifying the client code in the Service.

\subsubsection{Criteria / Filter Pattern (Structural)}
\textbf{Usage:} Used to filter emails based on multiple conditions.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Interface:} \texttt{Criteria} (defines \texttt{filter(List<Mail>)} method).
    \item \textbf{Concrete Criteria:} \texttt{CriteriaSender}, \texttt{CriteriaReceiver}, \texttt{CriteriaSubject}, \texttt{CriteriaBody}, \texttt{CriteriaPriority}, \texttt{CriteriaDay}, \texttt{CriteriaMonth}, \texttt{CriteriaYear}, \texttt{CriteriaHour}, \texttt{CriteriaMinute}, \texttt{CriteriaHasAttachment}.
\end{itemize}
This pattern decouples the filtering logic from the Mail entity and the Service.

\subsubsection{Factory Pattern (Creational)}
\textbf{Usage:} Used to instantiate the correct Filter/Criteria and Action objects based on user input.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \texttt{CriteriaFactory}: Takes a string (e.g., ``subject'') and returns a \texttt{CriteriaSubject} instance.
    \item \texttt{ActionFactory}: Takes an action type string (e.g., ``move'', ``star'', ``markasread'') and returns the corresponding \texttt{FilterRuleAction} implementation.
\end{itemize}
This encapsulates object creation logic, simplifying the Service layer.

\subsubsection{Builder Pattern (Creational)}
\textbf{Usage:} Used for constructing complex \texttt{Mail} objects.
\newline
\textbf{Implementation:} Annotated with \texttt{@Builder} (Lombok) in the \texttt{Mail} class. This provides a fluent API for object construction (\texttt{Mail.builder().subject(...).build()}), making the code more readable and reducing constructor complexity.

\subsubsection{Prototype Pattern (Creational)}
\textbf{Usage:} Used for deep-copying drafts when they are sent.
\newline
\textbf{Implementation:} The \texttt{Mail} class includes a Copy Constructor (\texttt{public Mail(Mail source)}) that creates a deep copy of the mail and its attachments, ensuring that the new ``Sent'' mail is a distinct entity from the original ``Draft''.

\subsubsection{Command Pattern (Behavioral)}
\textbf{Usage:} Used for executing filter rule actions on incoming emails.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Command Interface:} \texttt{FilterRuleAction} defines the \texttt{execute(Mail, String)} method.
    \item \textbf{Concrete Commands:} \texttt{MoveToAction}, \texttt{StarAction}, \texttt{MarkAsReadAction}.
    \item \textbf{Invoker:} \texttt{FilterRule} checks criteria and invokes actions.
    \item \textbf{Factory:} \texttt{ActionFactory} creates the appropriate action based on action type.
\end{itemize}

\subsubsection{Facade Pattern (Structural)}
\textbf{Usage:} Used to provide a simplified interface to complex subsystems.
\newline
\textbf{Implementation:} \texttt{MailService} acts as a facade, coordinating multiple repositories (\texttt{MailRepo}, \texttt{UserRepo}, \texttt{FolderRepo}), mappers, and the \texttt{ActionFactory} to provide high-level operations like \texttt{saveMail()}, \texttt{Search()}, and \texttt{Filter()}.

\subsubsection{Singleton Pattern (Creational)}
\textbf{Usage:} Ensures a class has only one instance.
\newline
\textbf{Implementation:} All Spring \texttt{@Service}, \texttt{@Repository}, and \texttt{@Component} annotated classes are managed as singletons by the Spring IoC container by default.

\subsubsection{Chain of Responsibility Pattern (Behavioral)}
\textbf{Usage:} Used for processing HTTP requests through security filters.
\newline
\textbf{Implementation:} \texttt{JWTFilter} extends \texttt{OncePerRequestFilter} and participates in Spring Security's filter chain, processing JWT tokens and passing requests to the next handler via \texttt{filterChain.doFilter()}.

\subsubsection{Mapper Pattern (Structural)}
\textbf{Usage:} Used to convert between DTOs and Entity objects.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \texttt{MailMapper} / \texttt{MailMapperImpl}: Converts \texttt{MailDTO} to \texttt{Mail} entity.
    \item \texttt{AttachmentMapper} / \texttt{AttachmentMapperImpl}: Converts attachment DTOs to \texttt{Attachment} entities.
\end{itemize}

\subsection{Frontend Design Patterns}

\subsubsection{Observer Pattern (Reactive Programming)}
\textbf{Usage:} Used for reactive state management and component communication.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Angular Signals:} Used for reactive local state (e.g., \texttt{currentFolder}, \texttt{selectedEmail}, \texttt{filters}).
    \item \textbf{RxJS Observables:} Used for HTTP communication and async data streams.
    \item \textbf{Computed Signals:} Derived state that automatically updates when dependencies change.
\end{itemize}

\subsubsection{Interceptor Pattern}
\textbf{Usage:} Used to intercept and modify HTTP requests globally.
\newline
\textbf{Implementation:} \texttt{AuthInterceptor} adds JWT Bearer tokens to all outgoing HTTP requests automatically.

\section{Design Decisions}
\begin{enumerate}
    \item \textbf{Framework Choice:} Spring Boot was chosen for its robust dependency injection and ease of REST API creation, enabling a clean Microservices-ready architecture.
    \item \textbf{Database:} PostgreSQL was selected for its reliability and advanced SQL features, running on port 5432.
    \item \textbf{Handling Concurrency:} To prevent issues where a user edits a draft while it is being autosaved, we implemented specific backend logic to always treat sent mails as new entities (via Prototype pattern), avoiding Optimistic Locking exceptions.
    \item \textbf{Asynchronous UI:} The Frontend uses Angular Signals and Observables to handle asynchronous file uploads (for large attachments), providing a non-blocking UI with a global loading overlay for better user experience.
    \item \textbf{Filter Rule Architecture:} Filter rules are applied on the receiver side when mail is being delivered, not on the sender side. This ensures each user's custom filters are applied to their incoming mail independently.
    \item \textbf{Defensive Null Handling:} All Criteria classes implement null-safe checks to prevent NPE during filter evaluation, with try-catch wrapper in mail delivery to ensure filter errors don't break mail sending.
\end{enumerate}

\section{Assumptions}
\begin{enumerate}
    \item \textbf{Email Composition:} When composing an email, the subject, body, and at least one valid receiver email are required. Empty fields are not permitted to ensure meaningful communication.
    \item \textbf{Email Validation:} Receiver email addresses must match the pattern \texttt{user@domain.com}. Invalid formats are rejected on the frontend before submission.
    \item \textbf{Priority Levels:} Emails support 5 priority levels: 1 (Very Low), 2 (Low), 3 (Normal - default), 4 (High), 5 (Extreme).
    \item \textbf{Folder Structure:} System folders (Inbox, Sent, Drafts, Trash, Starred) are created automatically for each user. Users can create custom folders.
    \item \textbf{Filter Actions:} Only one action can be applied per filter rule. Priority order: Move To Folder > Star > Mark as Read.
    \item \textbf{Authentication:} JWT tokens are stored in \texttt{sessionStorage} and automatically attached to all API requests via the interceptor.
    \item \textbf{Attachment Handling:} Attachments are deep-copied when sending drafts to ensure sender and receiver have independent copies in the database.
    \item \textbf{Trash Cleanup:} A scheduled service (\texttt{TrashCleanupService}) periodically cleans old emails from trash folders.
\end{enumerate}

\section{User Guide}
\subsection{Registration \& Login}
Users can sign up with a unique email. The system checks against the database and alerts if the email is taken.
\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Login/Signup Screenshot] \vspace{2cm}}}
    \caption{Login Page}
\end{figure}

\subsection{Inbox \& Filtering}
Users can view their inbox and apply filters (e.g., by Sender or Subject) and sort the results.
\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Inbox Screenshot] \vspace{2cm}}}
    \caption{Inbox with Filtering functionality}
\end{figure}

\subsection{Composing Emails}
The Compose window allows sending emails with priority and attachments. Subject, body, and receivers are mandatory fields.
\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Compose Window Screenshot] \vspace{2cm}}}
    \caption{Compose Email Modal}
\end{figure}

\subsection{Filter Rules}
Users can create custom filter rules to automatically organize incoming emails. Filter rules allow users to define criteria (sender, subject, body, priority, date, attachments) and actions (move to folder, star, mark as read) that are applied when emails matching the criteria are received.
\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Filter Rules Screenshot] \vspace{2cm}}}
    \caption{Filter Rules Management}
\end{figure}

\textbf{Available Criteria:}
\begin{itemize}
    \item From (sender email/name)
    \item To (recipient email)
    \item Subject contains
    \item Body contains keywords
    \item Priority level (1-5)
    \item Date (Year, Month, Day)
    \item Has attachments
\end{itemize}

\textbf{Available Actions:}
\begin{itemize}
    \item Move to folder (Inbox, Trash, or custom folders)
    \item Star the email
    \item Mark as read
\end{itemize}

\end{document}
