\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}
\usepackage{float}
\usepackage{enumitem}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Milo Mail System Project Report}
\author{
    Team Milo \\
    \vspace{0.3cm}
    Mostafa Fathy Ali Amer (23010849) \\
    Youssef Ashraf Mohamed Soliman (23010977) \\
    Anas Ali Mohamed Ahmed (23010300) \\
    Bigad Elsayed Ramadan Omar (23010327)
}
\date{}

\begin{document}

\maketitle

\section{Introduction}
This report covers the design and implementation of the Milo Mail System, which is a web-based email application we built for our Programming 2 course. We used \textbf{Spring Boot with JDK 21} for the backend and \textbf{Angular 20} for the frontend, along with a \textbf{PostgreSQL} database to store everything. We tried to follow Object-Oriented Programming principles and used several GoF design patterns to keep the code clean and easy to extend.

\section{Steps to Run the Code}
\subsection{Prerequisites}
\begin{itemize}
    \item Java Development Kit (JDK) 21
    \item Maven
    \item Node.js (v18+) and npm
    \item Angular CLI
    \item PostgreSQL Database (running on default port 5432)
\end{itemize}

\subsection{Database Setup}
\begin{enumerate}
    \item Ensure PostgreSQL is running on port \texttt{5432}.
    \item Create a database named \texttt{dilo}.
    \item Update credentials in \texttt{Milo-Backend/src/main/resources/application.properties} if they differ from:
    \begin{verbatim}
    spring.datasource.username=postgres
    spring.datasource.password=12345678
    \end{verbatim}
\end{enumerate}

\subsection{Backend Setup}
\begin{enumerate}
    \item Navigate to the \texttt{Milo-Backend} directory.
    \item Run the following command to start the server:
    \begin{verbatim}
    mvn spring-boot:run
    \end{verbatim}
    \item The backend API will start at \texttt{http://localhost:8080}.
\end{enumerate}

\subsection{Frontend Setup}
\begin{enumerate}
    \item Navigate to the \texttt{Milo} directory.
    \item Install dependencies:
    \begin{verbatim}
    npm install
    \end{verbatim}
    \item Start the development server:
    \begin{verbatim}
    ng serve
    \end{verbatim}
    \item Access the application in your browser at \texttt{http://localhost:4200}.
\end{enumerate}

\section{UML Diagrams}
\subsection{Class Diagram}
The Class Diagram illustrates the structural relationship between the core entities (\texttt{Mail}, \texttt{Attachment}, \texttt{User}) and the behavioral patterns (\texttt{Strategy} hierarchy for sorting, \texttt{Criteria} hierarchy for filtering).

\textit{(Please insert the generated class\_diagram.puml visualization here)}

\subsection{Sequence Diagrams}
We created three sequence diagrams to show different workflows in our system:

\subsubsection{Email Filtering \& Sorting}
This diagram shows how users can filter and sort their emails. It demonstrates the Strategy and Criteria patterns, along with the Caffeine caching mechanism.

\textit{(Please insert the generated filtering\_sorting\_sequence.puml visualization here)}

\subsubsection{Send Mail Workflow}
This diagram shows what happens when a user sends an email. It demonstrates the Prototype pattern for cloning mails and the Command pattern for applying filter rules on the receiver side.

\textit{(Please insert the generated send\_mail\_sequence.puml visualization here)}

\subsubsection{Authentication Flow}
This diagram shows the login process and how JWT tokens are handled. It demonstrates the Chain of Responsibility pattern in Spring Security and the Interceptor pattern on the frontend.

\textit{(Please insert the generated auth\_sequence.puml visualization here)}

\section{Design Patterns Applied}

\subsection{Backend Design Patterns}

\subsubsection{Strategy Pattern (Behavioral)}
\textbf{Usage:} Used for sorting emails and contacts dynamically.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Mail Sorting:} \texttt{MailSortingStrategy} interface with concrete implementations: \texttt{SortByDate}, \texttt{SortBySubject}, \texttt{SortByPriority}, \texttt{SortBySender}, \texttt{SortByReceiver}, \texttt{SortByBody}, \texttt{SortByAttachment}.
    \item \textbf{Contact Sorting:} \texttt{ContactSortingStrategy} interface with: \texttt{ContactSortByName}, \texttt{ContactSortByEmails}.
    \item \textbf{Context:} \texttt{SortWorker} and \texttt{ContactSortWorker} classes.
\end{itemize}
This allows the sorting algorithm to be switched at runtime without modifying the client code in the Service.

\subsubsection{Criteria / Filter Pattern (Structural)}
\textbf{Usage:} Used to filter emails based on multiple conditions.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Interface:} \texttt{Criteria} (defines \texttt{filter(List<Mail>)} method).
    \item \textbf{Concrete Criteria:} \texttt{CriteriaSender}, \texttt{CriteriaReceiver}, \texttt{CriteriaSubject}, \texttt{CriteriaBody}, \texttt{CriteriaPriority}, \texttt{CriteriaDay}, \texttt{CriteriaMonth}, \texttt{CriteriaYear}, \texttt{CriteriaHour}, \texttt{CriteriaMinute}, \texttt{CriteriaHasAttachment}.
\end{itemize}
This pattern decouples the filtering logic from the Mail entity and the Service.

\subsubsection{Factory Pattern (Creational)}
\textbf{Usage:} Used to instantiate the correct Filter/Criteria and Action objects based on user input.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \texttt{CriteriaFactory}: Takes a string (e.g., ``subject'') and returns a \texttt{CriteriaSubject} instance.
    \item \texttt{ActionFactory}: Takes an action type string (e.g., ``move'', ``star'', ``markasread'') and returns the corresponding \texttt{FilterRuleAction} implementation.
\end{itemize}
This encapsulates object creation logic, simplifying the Service layer.

\subsubsection{Builder Pattern (Creational)}
\textbf{Usage:} Used for constructing complex \texttt{Mail} objects.
\newline
\textbf{Implementation:} Annotated with \texttt{@Builder} (Lombok) in the \texttt{Mail} class. This provides a fluent API for object construction (\texttt{Mail.builder().subject(...).build()}), making the code more readable and reducing constructor complexity.

\subsubsection{Prototype Pattern (Creational)}
\textbf{Usage:} We use this pattern to deep-copy mails when sending them to multiple receivers or when sending a draft.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Interface:} \texttt{Prototype\textless T\textgreater} defines the \texttt{clone()} method.
    \item \textbf{Concrete Prototype:} \texttt{Mail} implements \texttt{Prototype\textless Mail\textgreater} with \texttt{clone()} and \texttt{cloneWithReceiver(ClientUser)} methods.
    \item The \texttt{clone()} method creates a deep copy of the mail including all attachments, ensuring each receiver gets their own independent copy.
\end{itemize}

\subsubsection{Command Pattern (Behavioral)}
\textbf{Usage:} Used for executing filter rule actions on incoming emails.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Command Interface:} \texttt{FilterRuleAction} defines the \texttt{execute(Mail, String)} method.
    \item \textbf{Concrete Commands:} \texttt{MoveToAction}, \texttt{StarAction}, \texttt{MarkAsReadAction}.
    \item \textbf{Invoker:} \texttt{FilterRule} checks criteria and invokes actions.
    \item \textbf{Factory:} \texttt{ActionFactory} creates the appropriate action based on action type.
\end{itemize}

\subsubsection{Facade Pattern (Structural)}
\textbf{Usage:} Used to provide a simplified interface to complex subsystems.
\newline
\textbf{Implementation:} \texttt{MailController} and \texttt{MailService} act as facades. The controller exposes simple REST endpoints to the frontend, while the service coordinates multiple repositories, mappers, and factories internally. This hides the complexity of the backend from the client.

\subsubsection{Singleton Pattern (Creational)}
\textbf{Usage:} Ensures a class has only one instance.
\newline
\textbf{Implementation:} All Spring \texttt{@Service}, \texttt{@Repository}, and \texttt{@Component} annotated classes are managed as singletons by the Spring IoC container by default.

\subsubsection{Chain of Responsibility Pattern (Behavioral)}
\textbf{Usage:} Used for processing HTTP requests through security filters.
\newline
\textbf{Implementation:} \texttt{JWTFilter} extends \texttt{OncePerRequestFilter} and participates in Spring Security's filter chain, processing JWT tokens and passing requests to the next handler via \texttt{filterChain.doFilter()}.

\subsubsection{Mapper Pattern (Structural)}
\textbf{Usage:} Used to convert between DTOs and Entity objects.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \texttt{MailMapper} / \texttt{MailMapperImpl}: Converts \texttt{MailDTO} to \texttt{Mail} entity.
    \item \texttt{AttachmentMapper} / \texttt{AttachmentMapperImpl}: Converts attachment DTOs to \texttt{Attachment} entities.
\end{itemize}

\subsection{Frontend Design Patterns}

\subsubsection{Observer Pattern (Reactive Programming)}
\textbf{Usage:} Used for reactive state management and component communication.
\newline
\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Angular Signals:} Used for reactive local state (e.g., \texttt{currentFolder}, \texttt{selectedEmail}, \texttt{filters}).
    \item \textbf{RxJS Observables:} Used for HTTP communication and async data streams.
    \item \textbf{Computed Signals:} Derived state that automatically updates when dependencies change.
\end{itemize}

\subsubsection{Interceptor Pattern}
\textbf{Usage:} Used to intercept and modify HTTP requests globally.
\newline
\textbf{Implementation:} \texttt{AuthInterceptor} adds JWT Bearer tokens to all outgoing HTTP requests automatically.

\section{Design Decisions}
\begin{enumerate}
    \item \textbf{Framework Choice:} We went with Spring Boot because it makes building REST APIs really easy and has great dependency injection. It also means we could scale this to microservices later if needed.
    \item \textbf{Database:} We picked PostgreSQL since it's reliable and has advanced SQL features. It runs on port 5432.
    \item \textbf{Caching with Caffeine:} We noticed that loading mails was getting slow, especially when users had lots of emails. To fix this, we added a caching layer using Caffeine. We chose Caffeine because it's a local cache that can store Java objects directly without needing to serialize them, which is really convenient.
    \item \textbf{Handling Concurrency:} To avoid issues where a user edits a draft while it's being autosaved, we made the backend always treat sent mails as brand new entities using the Prototype pattern. This prevents those annoying Optimistic Locking exceptions.
    \item \textbf{Asynchronous UI:} The frontend uses Angular Signals and Observables for handling large file uploads asynchronously. We also added a global loading overlay so users can see when something is still loading.
    \item \textbf{Filter Rule Architecture:} Filter rules get applied on the receiver's side when mail is delivered, not the sender's side. This way each user's filters work independently on their own incoming mail.
    \item \textbf{Synchronized Star Status for Self-Sent Emails:} When you send an email to yourself, you end up with two copies (one in Sent, one in Inbox). We made it so starring either copy automatically stars both. Also, the Starred folder only shows one copy to avoid duplicates.
\end{enumerate}

\section{Assumptions}
\begin{enumerate}
    \item \textbf{Email Composition:} When composing an email, the subject, body, and at least one valid receiver email are required. Empty fields are not permitted to ensure meaningful communication.
    \item \textbf{Email Validation:} Receiver email addresses must match the pattern \texttt{user@domain.com}. Invalid formats are rejected on the frontend before submission.
    \item \textbf{Priority Levels:} Emails support 5 priority levels: 1 (Very Low), 2 (Low), 3 (Normal - default), 4 (High), 5 (Extreme).
    \item \textbf{Folder Structure:} System folders (Inbox, Sent, Drafts, Trash, Starred) are created automatically for each user. Users can create custom folders.
    \item \textbf{Filter Actions:} Only one action can be applied per filter rule. Priority order: Move To Folder > Star > Mark as Read.
    \item \textbf{Authentication:} JWT tokens are stored in \texttt{sessionStorage} and automatically attached to all API requests via the interceptor.
    \item \textbf{Attachment Handling:} Attachments are deep-copied when sending drafts to ensure sender and receiver have independent copies in the database.
    \item \textbf{Trash Cleanup:} A scheduled service (\texttt{TrashCleanupService}) periodically cleans old emails from trash folders.
\end{enumerate}

\section{User Guide}

\subsection{Registration}
New users can create an account by providing their name, email, and password. The system validates that the email is unique and follows the correct format.

\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Signup Screenshot] \vspace{2cm}}}
    \caption{User Registration Page}
\end{figure}

\subsection{Login}
Registered users can log in with their email and password. Upon successful authentication, a JWT token is generated and stored for subsequent requests.

\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Login Screenshot] \vspace{2cm}}}
    \caption{User Login Page}
\end{figure}

\subsection{Inbox \& Email Management}
The inbox displays all received emails with information like sender, subject, date, and priority. Users can:
\begin{itemize}
    \item Filter emails by various criteria
    \item Sort emails by date, subject, sender, or priority
    \item Star important emails
    \item Move emails to different folders
\end{itemize}

\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Inbox Screenshot] \vspace{2cm}}}
    \caption{Inbox View with Email List}
\end{figure}

\subsection{Composing Emails}
The compose window allows users to create and send emails. Features include:
\begin{itemize}
    \item Multiple recipients support
    \item Priority levels (1-5)
    \item File attachments
    \item Auto-save as draft
\end{itemize}

\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Compose Window Screenshot] \vspace{2cm}}}
    \caption{Email Compose Window}
\end{figure}

\subsection{Filter Rules}
Users can create custom filter rules to automatically organize incoming emails based on criteria and actions.

\begin{figure}[H]
    \centering
    \fbox{\parbox{10cm}{\centering \vspace{2cm} [Insert Filter Rules Screenshot] \vspace{2cm}}}
    \caption{Filter Rules Management}
\end{figure}

\noindent\textbf{Available Criteria:}
\begin{itemize}
    \item From (sender email/name)
    \item To (recipient email)
    \item Subject contains
    \item Body contains keywords
    \item Priority level (1-5)
    \item Date (Year, Month, Day)
    \item Has attachments
\end{itemize}

\noindent\textbf{Available Actions:}
\begin{itemize}
    \item Move to folder (Inbox, Trash, or custom folders)
    \item Star the email
    \item Mark as read
\end{itemize}

\end{document}
